#
# Atom CircleCI Orb
#

version: 2.1
description: Commands useful for building + deploying elements in the Atom system

#
# Section for setting repeatedly used yaml anchors/aliases
#
aliases:

  #
  # Basic Docker Build
  #

  # Basic build Arguments
  - &build_args
      working_directory:
        type: string
        default: "."
      file:
        type: string
        default: Dockerfile
      target_image:
        type: string
      target_tag:
        type: string
      stage:
        type: string
        default: ""
      build_args:
        type: string
        default: ""
      no_output_timeout:
        type: string
        default: 15m
      use_git_lfs:
        type: boolean
        default: false
      cache_repo:
        type: string
        default: ""
      cache_tag:
        type: string
        default: ""
      executor:
        type: executor
        default: build-ubuntu

  # Mapping to pass build args through without modification
  - &build_args_mapping
      working_directory: << parameters.working_directory >>
      file: << parameters.file >>
      target_image: << parameters.target_image >>
      target_tag: << parameters.target_tag >>
      stage: << parameters.stage >>
      build_args: << parameters.build_args >>
      no_output_timeout: << parameters.no_output_timeout >>
      use_git_lfs: << parameters.use_git_lfs >>
      cache_repo: << parameters.cache_repo >>
      cache_tag: << parameters.cache_tag >>

  # Atom build arguments
  - &atom_build_args
      atom_repo:
        type: string
        default: elementaryrobotics/atom
      atom_tag:
        type: string
      atom_version:
        type: string

  #
  # Test
  #

  - &test_shared_args
      nucleus_repo:
        type: string
        default: elementaryrobotics/nucleus
      atom_version:
        type: string
      test_image:
        type: string
      test_tag:
        type: string
      compose_file:
        type: string
      compose_addl_args:
        type: string
        default: ""
      container_name:
        type: string
      container_test_dir:
        type: string
        default: "."
      test_cmd:
        type: string
      use_git_lfs:
        type: boolean
        default: false
      executor:
        type: executor
        default: build-ubuntu

  - &test_shared_args_mapping
      nucleus_repo: << parameters.nucleus_repo >>
      atom_version: << parameters.atom_version >>
      test_image: << parameters.test_image >>
      test_tag: << parameters.test_tag >>
      compose_file: << parameters.compose_file >>
      compose_addl_args: << parameters.compose_addl_args >>
      container_name: << parameters.container_name >>
      container_test_dir: << parameters.container_test_dir >>
      test_cmd: << parameters.test_cmd >>
      use_git_lfs: << parameters.use_git_lfs >>

  #
  # Deployment
  #

  # Deploy shared arguments. Note that target_tag_cmd isn't included
  # here but is an expected argument.
  - &deploy_shared_args
      source_image:
        type: string
      source_tag:
        type: string
      target_image:
        type: string
      target_tag:
        type: string
        default: ""
      platforms:
        type: string

  # Deploy argument mapping
  - &deploy_shared_args_mapping
      platforms: << parameters.platforms >>
      source_image: << parameters.source_image >>
      source_tag: << parameters.source_tag >>
      target_image: << parameters.target_image >>
      target_tag: << parameters.target_tag >>
      target_tag_cmd: << parameters.target_tag_cmd >>

#
# Machines that can be used for build. Build-classic is typically
# what you want to use.
#
executors:

  # Ubuntu Machine used to build some images
  # Docker v20.10.2, Docker Compose v1.28.2,
  # This is useful since `buildx`, which is required in order
  # to cross-compile images, comes standard in Docker 19.03. There are
  # some buildx bugs that caused layers/files to be dropped that might be
  # resolved in 20.10.0, so we should ensure we're running a version
  # newer than this.

  build-ubuntu:
    machine:
      enabled: true
      image: ubuntu-2004:202101-01
    environment:
      DOCKER_CLI_EXPERIMENTAL: enabled
    resource_class: medium

  build-ubuntu-large:
    machine:
      enabled: true
      image: ubuntu-2004:202101-01
    environment:
      DOCKER_CLI_EXPERIMENTAL: enabled
    resource_class: large

  build-ubuntu-arm:
    machine:
      enabled: true
      image: ubuntu-2004:202101-01
    environment:
      DOCKER_CLI_EXPERIMENTAL: enabled
    resource_class: arm.medium

  build-ubuntu-arm-large:
    machine:
      enabled: true
      image: ubuntu-2004:202101-01
    environment:
      DOCKER_CLI_EXPERIMENTAL: enabled
    resource_class: arm.large

  # Docker-in-docker. Need to call setup_remote_docker
  # before using. Useful when you don't need a bunch of
  # CPU and are just deploying things
  docker-in-docker:
    docker:
      - image: cimg/base:2020.01
    resource_class: small

#
# Commands that are useful for build and deploy
#
commands:

  # Install Git LFS
  install_git_lfs:
    description: Install Git Large File Storage (LFS) in ubuntu
    steps:
      - run:
          name: Download and install Git LFS
          command: |
            curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
            sudo apt-get install -f git-lfs && git lfs install
      - run:
          name: Authenticate Git LFS
          command: |
            mkdir -p ~/.ssh/ && echo -e "Host github.com\n\tStrictHostKeyChecking no\n" > ~/.ssh/config
            ssh-keyscan -H github.com >> ~/.ssh/known_hosts
            ssh git@github.com git-lfs-authenticate "${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}" download

  # Update submodules (parallelized)
  update_submodules:
    steps:
      - run:
          name: Update Submodules
          command: git submodule update --init --recursive --jobs 8

  # Log into docker
  docker_login:
    description: "Logs into Dockerhub"
    steps:
      - run:
          name: Docker Login
          command: echo ${DOCKERHUB_PASSWORD} | docker login -u ${DOCKERHUB_USER} --password-stdin

  # Launch a compose file. Since it runs docker-compose up -d if the container
  # is already up then this will be a No-op. This is nice s.t. we can call the
  # test command multiple times without issue/relaunch
  run_compose:
    description: "Launch docker-compose"
    parameters:
      file:
        type: string
        default: docker-compose.yml
      build_args:
        type: string
        default: ""
    steps:
      - run:
          name: Launch docker-compose
          command: << parameters.build_args >> docker-compose -f << parameters.file >> up -d

  pull_image:
    description: "Pull image for a particular platform"
    parameters:
      source_image:
        type: string
      source_tag:
        type: string
    steps:
      - run:
          name: Pull image  << parameters.source_image >>:<< parameters.source_tag >>
          command: docker pull << parameters.source_image >>:<< parameters.source_tag >>-$(arch)

  push_image:
    description: "Deploy a Docker image for a particular platform"
    parameters:
      target_image:
        type: string
      target_tag:
        type: string
    steps:
      - push_image:
          target_image: << parameters.target_image >>
          target_tag: << parameters.target_tag >>-$(arch)

  # Create and push image tag
  tag_and_push_image:
    description: "Tag the latest docker image and deploy it"
    parameters:
      << : *deploy_shared_args
      target_tag_cmd:
        description: grep-like modification command to be run on the target tag. Useful for when you need to use CircleCI's matrix params to launch a job with a tag that's close but not identical to the one you want to deploy.
        type: string
        default: "grep '.*'"
    steps:
      - run:
          name: Tag image source:<< parameters.source_image >>:<< parameters.source_tag >>-$(arch) target:<< parameters.target_image >>:<< parameters.target_tag >> tag_cmd:<< parameters.target_tag_cmd >>
          command: docker tag << parameters.source_image >>:<< parameters.source_tag >>-$(arch) << parameters.target_image >>:$(echo << parameters.target_tag >> | << parameters.target_tag_cmd >>)
      - run:
          name: Push image target:<< parameters.target_image >>:<< parameters.target_tag >> tag_cmd:<< parameters.target_tag_cmd >>
          command: docker push << parameters.target_image >>:$(echo << parameters.target_tag >> | << parameters.target_tag_cmd >>)

  deploy_image:
    parameters:
      << : *deploy_shared_args
      target_tag_cmd:
        type: string
        default: grep ".*"
    steps:
      - docker_login
      - pull_image:
          source_image: << parameters.source_image >>
          source_tag: << parameters.source_tag >>
      - tag_and_push_image:
          << : *deploy_shared_args_mapping

  # Prepare the machine for buildx based builds
  enable_buildx:
    description: "Prepare the CircleCI machine for using buildx"
    steps:
      - run:
          name: Switch to the multi-arch builder
          command: docker buildx ls | grep "build-buildx" || docker buildx create --use --name build-buildx
      - run:
          name: Start up buildx and inspect
          command: docker buildx inspect --bootstrap

  # Run a Dockerfile build command and tags the resultant image with
  # << parameters.target_image >>:<< parameters.target_tag >>-$(arch)
  run_dockerfile_build:
    parameters:
      << : *build_args
      cache_to:
        type: string
        default: ""
      build_context:
        type: string
        default: "."
      exit_override:
        type: string
        default: ""
      atom_base_arg:
        type: string
    steps:
      - run:
          name: "Build Dockerfile << parameters.file >> stage << parameters.stage >> using << parameters.build_invocation >>"
          working_directory: << parameters.working_directory >>
          command: >-
            docker buildx build
            --progress plain
            --load
            --cache-from=type=registry,ref=<< parameters.cache_repo >>:<< parameters.cache_tag >>-$(arch)
            << parameters.cache_to >>
            --label "com.elementaryrobotics.tag=${CIRCLE_TAG}"
            --label "com.elementaryrobotics.branch=${CIRCLE_BRANCH}"
            --label "com.elementaryrobotics.repo=${CIRCLE_PROJECT_REPONAME}"
            --label "com.elementaryrobotics.commit=${CIRCLE_SHA1}"
            --label "com.elementaryrobotics.describe=$(git describe --tags)"
            --label "com.elementaryrobotics.build_num=${CIRCLE_BUILD_NUM}"
            --label "com.elementaryrobotics.build_url=${CIRCLE_BUILD_URL}"
            -t << parameters.target_image >>:<< parameters.target_tag >>-$(arch)
            -f << parameters.file >>
            << parameters.atom_base_arg >>
            << parameters.build_args >>
            --target=<< parameters.stage >>
            --pull
            << parameters.build_context >>
            << parameters.exit_override >>
          no_output_timeout: << parameters.no_output_timeout >>

  # Build a Dockerfile using docker buildx build
  build_dockerfile:
    description: "Build and tag a Dockerfile using buildx"
    parameters:
      << : *build_args
      atom_base_arg:
        type: string
        default: ""
    steps:
      - enable_buildx

      # Run the actual build. Due to a bug in the buildx cache pushing
      # in that it's failing intermittently we don't set the
      # --cache-to field when doing this
      - run_dockerfile_build:
          << : *build_args_mapping
          atom_base_arg: << parameters.atom_base_arg >>

      # Run the build again. This should add a small overhead but everything
      # should be in cache locally. As such, the point of this one is just
      # to push the cache out. We're also OK if this fails. Override the context
      # field to add one more thing in easily
      - run_dockerfile_build:
          << : *build_args_mapping
          exit_override: "|| exit 0"
          cache_to: --cache-to=type=registry,ref=<< parameters.cache_repo >>:<< parameters.cache_tag >>-$(arch),mode=max
          atom_base_arg: << parameters.atom_base_arg >>

  run_test:
    parameters:
      << : *test_shared_args
    steps:
      - enable_buildx
      - run_compose:
          file: << parameters.compose_file >>
          build_args: << parameters.compose_addl_args >> NUCLEUS_IMAGE=<< parameters.nucleus_repo >>:<< parameters.atom_version >>-stock-$(arch) TEST_IMAGE=<< parameters.test_image >>:<< parameters.test_tag >>-$(arch)
      - run:
          name: Run Tests
          command: docker exec -it -w << parameters.container_test_dir >> << parameters.container_name >> << parameters.test_cmd >>

#
# Jobs that are nice to be able to share between elements
#
jobs:

  # Run ER formatting check
  check_formatting:
    docker:
      - image: elementaryrobotics/formatter
    resource_class: small
    description: Check formatting against flake8 and optionally black
    parameters:
      flake8_exclude:
        description: Flake8 exclude string
        type: string
        default: ""
      black_exclude:
        description: Black exclude string
        type: string
        default: ""
      use_black:
        description: Whether to use black or not. Set to empty string for no
        type: string
        default: "y"
    steps:
      - checkout
      - run:
          name: Check Formatting
          description: Run black & flake8 checks
          command: CODE_DIR=/root/project FLAKE8_EXCLUDE=<< parameters.flake8_exclude>> BLACK_EXCLUDE=<< parameters.black_exclude >> FORMAT_BLACK=<< parameters.use_black >> /usr/local/bin/run.sh

  build_image:
    parameters:
      << : *build_args
    executor: << parameters.executor >>
    steps:
      - when:
          condition: << parameters.use_git_lfs >>
          steps:
            - install_git_lfs
      - checkout
      - update_submodules
      - docker_login
      - build_dockerfile:
          << : *build_args_mapping
      - push_image:
          target_image: << parameters.target_image >>
          target_tag: << parameters.target_tag >>

  build_element:
    parameters:
      << : *build_args
      << : *atom_build_args
    executor: << parameters.executor >>
    steps:
      - when:
          condition: << parameters.use_git_lfs >>
          steps:
            - install_git_lfs
      - checkout
      - update_submodules
      - docker_login
      - build_dockerfile:
          << : *build_args_mapping
          atom_base_arg: --build-arg ATOM_IMAGE=<< parameters.atom_repo >>:<< parameters.atom_tag >>-<< parameters.atom_version >>
      - push_image:
          target_image: << parameters.target_image >>
          target_tag: << parameters.target_tag >>

  test:
    parameters:
      << : *test_shared_args
    executor: << parameters.executor >>
    steps:
      - when:
          condition: << parameters.use_git_lfs >>
          steps:
            - install_git_lfs
      - checkout
      - docker_login
      - run_test:
          << : *test_shared_args_mapping

  # Deploy an Image
  deploy:
    executor: docker-in-docker
    parameters:
      << : *deploy_shared_args
      target_tag_cmd:
        type: string
        # By default, strip off "-stock" and "-amd64" tags so that builds
        # show up with the legacy tags of development-YYY, latest-YYY, etc.
        default: sed s/-stock//g | sed s/-amd64//g
    steps:
      - setup_remote_docker
      - deploy_image:
          << : *deploy_shared_args_mapping

  # Special case: deploy release tags. Requires a different tag command
  deploy_release:
    executor: docker-in-docker
    parameters:
      << : *deploy_shared_args
      target_tag_cmd:
        type: string
        # By default, we want -stock-amd64 to map to "latest", we want
        # "-amd64" stripped off of all builds since it's implied/default
        # and we want _-stock-aarch64 to be just "aarch64" for ease.
        # This is a bit convoluted.
        default: grep -oP "(?<=-).*" | sed s/stock/latest/g | sed s/-amd64//g | sed s/latest-aarch64/aarch64/g
    steps:
      - setup_remote_docker
      - deploy_image:
          << : *deploy_shared_args_mapping
